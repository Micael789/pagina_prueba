{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\jejef\\\\OneDrive\\\\windsurf\\\\proyecto-vinculacion-acciones-QR\\\\frontend\\\\src\\\\services\\\\SyncContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n/**\n * Context para manejo de sincronización offline\n * Gestiona eventos pendientes y sincronización automática\n */\n\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport localforage from 'localforage';\nimport { apiService } from './apiService';\nimport { v4 as uuidv4 } from 'uuid';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SyncContext = /*#__PURE__*/createContext(null);\nexport function useSync() {\n  _s();\n  const context = useContext(SyncContext);\n  if (!context) {\n    throw new Error('useSync debe usarse dentro de un SyncProvider');\n  }\n  return context;\n}\n_s(useSync, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport function SyncProvider({\n  children\n}) {\n  _s2();\n  const [pendingEvents, setPendingEvents] = useState([]);\n  const [syncing, setSyncing] = useState(false);\n  const [lastSync, setLastSync] = useState(null);\n\n  // Cargar eventos pendientes al iniciar\n  useEffect(() => {\n    loadPendingEvents();\n    loadLastSync();\n  }, []);\n\n  // Sincronizar automáticamente cuando se conecta\n  useEffect(() => {\n    const handleOnline = () => {\n      if (pendingEvents.length > 0) {\n        syncPendingEvents();\n      }\n    };\n    window.addEventListener('online', handleOnline);\n    return () => window.removeEventListener('online', handleOnline);\n  }, [pendingEvents]);\n\n  /**\n   * Carga eventos pendientes desde almacenamiento local\n   */\n  const loadPendingEvents = async () => {\n    try {\n      const events = (await localforage.getItem('pending_events')) || [];\n      setPendingEvents(events);\n    } catch (error) {\n      console.error('Error cargando eventos pendientes:', error);\n    }\n  };\n\n  /**\n   * Carga timestamp del último sync\n   */\n  const loadLastSync = async () => {\n    try {\n      const timestamp = await localforage.getItem('last_sync');\n      setLastSync(timestamp);\n    } catch (error) {\n      console.error('Error cargando último sync:', error);\n    }\n  };\n\n  /**\n   * Guarda evento offline para sincronizar después\n   */\n  const saveEventOffline = async (unitId, eventData, photo = null) => {\n    try {\n      const event = {\n        id: uuidv4(),\n        unit_id: unitId,\n        eventData: {\n          ...eventData,\n          idempotency_key: eventData.idempotency_key || uuidv4()\n        },\n        photo: photo,\n        timestamp: new Date().toISOString(),\n        synced: false\n      };\n\n      // Guardar foto en almacenamiento local si existe\n      if (photo) {\n        const photoKey = `photo_${event.id}`;\n        await localforage.setItem(photoKey, photo);\n        event.photoKey = photoKey;\n      }\n      const currentEvents = (await localforage.getItem('pending_events')) || [];\n      const updatedEvents = [...currentEvents, event];\n      await localforage.setItem('pending_events', updatedEvents);\n      setPendingEvents(updatedEvents);\n      return {\n        success: true,\n        event\n      };\n    } catch (error) {\n      console.error('Error guardando evento offline:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  };\n\n  /**\n   * Sincroniza eventos pendientes con el servidor\n   */\n  const syncPendingEvents = async () => {\n    if (syncing || !navigator.onLine || pendingEvents.length === 0) {\n      return;\n    }\n    setSyncing(true);\n    try {\n      const eventsToSync = [...pendingEvents];\n      const syncResults = [];\n      for (const event of eventsToSync) {\n        try {\n          let photo = null;\n\n          // Recuperar foto si existe\n          if (event.photoKey) {\n            photo = await localforage.getItem(event.photoKey);\n          }\n\n          // Intentar sincronizar con el servidor\n          const result = await apiService.createEvent(event.unit_id, event.eventData, photo);\n          syncResults.push({\n            ...event,\n            synced: true,\n            syncResult: result\n          });\n\n          // Limpiar foto del almacenamiento local\n          if (event.photoKey) {\n            await localforage.removeItem(event.photoKey);\n          }\n        } catch (error) {\n          var _error$response, _error$response$data;\n          console.error('Error sincronizando evento:', error);\n\n          // Si el error es por evento duplicado, marcarlo como sincronizado\n          if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.code) === 'DUPLICATE_EVENT') {\n            syncResults.push({\n              ...event,\n              synced: true,\n              syncResult: {\n                duplicate: true\n              }\n            });\n          } else {\n            var _error$response2, _error$response2$data;\n            // Mantener el evento para reintentar después\n            syncResults.push({\n              ...event,\n              synced: false,\n              lastError: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.message) || error.message\n            });\n          }\n        }\n      }\n\n      // Filtrar eventos que no se han sincronizado\n      const remainingEvents = syncResults.filter(event => !event.synced);\n\n      // Actualizar almacenamiento local\n      await localforage.setItem('pending_events', remainingEvents);\n      setPendingEvents(remainingEvents);\n\n      // Actualizar timestamp del último sync\n      const now = new Date().toISOString();\n      await localforage.setItem('last_sync', now);\n      setLastSync(now);\n      return {\n        success: true,\n        synced: syncResults.filter(e => e.synced).length,\n        failed: remainingEvents.length\n      };\n    } catch (error) {\n      console.error('Error en sincronización:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    } finally {\n      setSyncing(false);\n    }\n  };\n\n  /**\n   * Registra evento - online o offline según conectividad\n   */\n  const registerEvent = async (unitId, eventData, photo = null) => {\n    // Generar clave de idempotencia si no existe\n    if (!eventData.idempotency_key) {\n      eventData.idempotency_key = uuidv4();\n    }\n    if (navigator.onLine) {\n      try {\n        // Intentar enviar directamente\n        const result = await apiService.createEvent(unitId, eventData, photo);\n        return {\n          success: true,\n          result,\n          offline: false\n        };\n      } catch (error) {\n        // Si falla, guardar offline\n        console.warn('Error enviando evento, guardando offline:', error);\n        const offlineResult = await saveEventOffline(unitId, eventData, photo);\n        return {\n          ...offlineResult,\n          offline: true\n        };\n      }\n    } else {\n      // Sin conexión, guardar offline\n      const offlineResult = await saveEventOffline(unitId, eventData, photo);\n      return {\n        ...offlineResult,\n        offline: true\n      };\n    }\n  };\n\n  /**\n   * Limpia todos los eventos pendientes\n   */\n  const clearPendingEvents = async () => {\n    try {\n      await localforage.removeItem('pending_events');\n      setPendingEvents([]);\n    } catch (error) {\n      console.error('Error limpiando eventos pendientes:', error);\n    }\n  };\n\n  /**\n   * Obtiene estadísticas de sincronización\n   */\n  const getSyncStats = () => {\n    return {\n      pending: pendingEvents.length,\n      syncing,\n      lastSync,\n      hasConnection: navigator.onLine\n    };\n  };\n  const value = {\n    pendingEvents,\n    syncing,\n    lastSync,\n    registerEvent,\n    syncPendingEvents,\n    clearPendingEvents,\n    getSyncStats\n  };\n  return /*#__PURE__*/_jsxDEV(SyncContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 255,\n    columnNumber: 5\n  }, this);\n}\n_s2(SyncProvider, \"U2fSeoYr3Isy2XuH0HAMHalXNF4=\");\n_c = SyncProvider;\nvar _c;\n$RefreshReg$(_c, \"SyncProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","localforage","apiService","v4","uuidv4","jsxDEV","_jsxDEV","SyncContext","useSync","_s","context","Error","SyncProvider","children","_s2","pendingEvents","setPendingEvents","syncing","setSyncing","lastSync","setLastSync","loadPendingEvents","loadLastSync","handleOnline","length","syncPendingEvents","window","addEventListener","removeEventListener","events","getItem","error","console","timestamp","saveEventOffline","unitId","eventData","photo","event","id","unit_id","idempotency_key","Date","toISOString","synced","photoKey","setItem","currentEvents","updatedEvents","success","message","navigator","onLine","eventsToSync","syncResults","result","createEvent","push","syncResult","removeItem","_error$response","_error$response$data","response","data","code","duplicate","_error$response2","_error$response2$data","lastError","remainingEvents","filter","now","e","failed","registerEvent","offline","warn","offlineResult","clearPendingEvents","getSyncStats","pending","hasConnection","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/jejef/OneDrive/windsurf/proyecto-vinculacion-acciones-QR/frontend/src/services/SyncContext.js"],"sourcesContent":["/**\n * Context para manejo de sincronización offline\n * Gestiona eventos pendientes y sincronización automática\n */\n\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport localforage from 'localforage';\nimport { apiService } from './apiService';\nimport { v4 as uuidv4 } from 'uuid';\n\nconst SyncContext = createContext(null);\n\nexport function useSync() {\n  const context = useContext(SyncContext);\n  if (!context) {\n    throw new Error('useSync debe usarse dentro de un SyncProvider');\n  }\n  return context;\n}\n\nexport function SyncProvider({ children }) {\n  const [pendingEvents, setPendingEvents] = useState([]);\n  const [syncing, setSyncing] = useState(false);\n  const [lastSync, setLastSync] = useState(null);\n\n  // Cargar eventos pendientes al iniciar\n  useEffect(() => {\n    loadPendingEvents();\n    loadLastSync();\n  }, []);\n\n  // Sincronizar automáticamente cuando se conecta\n  useEffect(() => {\n    const handleOnline = () => {\n      if (pendingEvents.length > 0) {\n        syncPendingEvents();\n      }\n    };\n\n    window.addEventListener('online', handleOnline);\n    return () => window.removeEventListener('online', handleOnline);\n  }, [pendingEvents]);\n\n  /**\n   * Carga eventos pendientes desde almacenamiento local\n   */\n  const loadPendingEvents = async () => {\n    try {\n      const events = await localforage.getItem('pending_events') || [];\n      setPendingEvents(events);\n    } catch (error) {\n      console.error('Error cargando eventos pendientes:', error);\n    }\n  };\n\n  /**\n   * Carga timestamp del último sync\n   */\n  const loadLastSync = async () => {\n    try {\n      const timestamp = await localforage.getItem('last_sync');\n      setLastSync(timestamp);\n    } catch (error) {\n      console.error('Error cargando último sync:', error);\n    }\n  };\n\n  /**\n   * Guarda evento offline para sincronizar después\n   */\n  const saveEventOffline = async (unitId, eventData, photo = null) => {\n    try {\n      const event = {\n        id: uuidv4(),\n        unit_id: unitId,\n        eventData: {\n          ...eventData,\n          idempotency_key: eventData.idempotency_key || uuidv4()\n        },\n        photo: photo,\n        timestamp: new Date().toISOString(),\n        synced: false\n      };\n\n      // Guardar foto en almacenamiento local si existe\n      if (photo) {\n        const photoKey = `photo_${event.id}`;\n        await localforage.setItem(photoKey, photo);\n        event.photoKey = photoKey;\n      }\n\n      const currentEvents = await localforage.getItem('pending_events') || [];\n      const updatedEvents = [...currentEvents, event];\n      \n      await localforage.setItem('pending_events', updatedEvents);\n      setPendingEvents(updatedEvents);\n\n      return { success: true, event };\n    } catch (error) {\n      console.error('Error guardando evento offline:', error);\n      return { success: false, error: error.message };\n    }\n  };\n\n  /**\n   * Sincroniza eventos pendientes con el servidor\n   */\n  const syncPendingEvents = async () => {\n    if (syncing || !navigator.onLine || pendingEvents.length === 0) {\n      return;\n    }\n\n    setSyncing(true);\n\n    try {\n      const eventsToSync = [...pendingEvents];\n      const syncResults = [];\n\n      for (const event of eventsToSync) {\n        try {\n          let photo = null;\n          \n          // Recuperar foto si existe\n          if (event.photoKey) {\n            photo = await localforage.getItem(event.photoKey);\n          }\n\n          // Intentar sincronizar con el servidor\n          const result = await apiService.createEvent(\n            event.unit_id,\n            event.eventData,\n            photo\n          );\n\n          syncResults.push({\n            ...event,\n            synced: true,\n            syncResult: result\n          });\n\n          // Limpiar foto del almacenamiento local\n          if (event.photoKey) {\n            await localforage.removeItem(event.photoKey);\n          }\n\n        } catch (error) {\n          console.error('Error sincronizando evento:', error);\n          \n          // Si el error es por evento duplicado, marcarlo como sincronizado\n          if (error.response?.data?.code === 'DUPLICATE_EVENT') {\n            syncResults.push({\n              ...event,\n              synced: true,\n              syncResult: { duplicate: true }\n            });\n          } else {\n            // Mantener el evento para reintentar después\n            syncResults.push({\n              ...event,\n              synced: false,\n              lastError: error.response?.data?.message || error.message\n            });\n          }\n        }\n      }\n\n      // Filtrar eventos que no se han sincronizado\n      const remainingEvents = syncResults.filter(event => !event.synced);\n      \n      // Actualizar almacenamiento local\n      await localforage.setItem('pending_events', remainingEvents);\n      setPendingEvents(remainingEvents);\n\n      // Actualizar timestamp del último sync\n      const now = new Date().toISOString();\n      await localforage.setItem('last_sync', now);\n      setLastSync(now);\n\n      return {\n        success: true,\n        synced: syncResults.filter(e => e.synced).length,\n        failed: remainingEvents.length\n      };\n\n    } catch (error) {\n      console.error('Error en sincronización:', error);\n      return { success: false, error: error.message };\n    } finally {\n      setSyncing(false);\n    }\n  };\n\n  /**\n   * Registra evento - online o offline según conectividad\n   */\n  const registerEvent = async (unitId, eventData, photo = null) => {\n    // Generar clave de idempotencia si no existe\n    if (!eventData.idempotency_key) {\n      eventData.idempotency_key = uuidv4();\n    }\n\n    if (navigator.onLine) {\n      try {\n        // Intentar enviar directamente\n        const result = await apiService.createEvent(unitId, eventData, photo);\n        return { success: true, result, offline: false };\n      } catch (error) {\n        // Si falla, guardar offline\n        console.warn('Error enviando evento, guardando offline:', error);\n        const offlineResult = await saveEventOffline(unitId, eventData, photo);\n        return { ...offlineResult, offline: true };\n      }\n    } else {\n      // Sin conexión, guardar offline\n      const offlineResult = await saveEventOffline(unitId, eventData, photo);\n      return { ...offlineResult, offline: true };\n    }\n  };\n\n  /**\n   * Limpia todos los eventos pendientes\n   */\n  const clearPendingEvents = async () => {\n    try {\n      await localforage.removeItem('pending_events');\n      setPendingEvents([]);\n    } catch (error) {\n      console.error('Error limpiando eventos pendientes:', error);\n    }\n  };\n\n  /**\n   * Obtiene estadísticas de sincronización\n   */\n  const getSyncStats = () => {\n    return {\n      pending: pendingEvents.length,\n      syncing,\n      lastSync,\n      hasConnection: navigator.onLine\n    };\n  };\n\n  const value = {\n    pendingEvents,\n    syncing,\n    lastSync,\n    registerEvent,\n    syncPendingEvents,\n    clearPendingEvents,\n    getSyncStats\n  };\n\n  return (\n    <SyncContext.Provider value={value}>\n      {children}\n    </SyncContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}